# -*- coding: utf-8 -*-
"""Aya_Ibrahim_Al-Sayed1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wBS5ybPnHGm3hTyHd4HSLLJq7255lzDP
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
#
import numpy as np
#this library will help us in analysing data
import matplotlib.pyplot as plt
#this library help us in visualization
# %matplotlib inline
# we use this code so that the the visualization image show in the same tab not in a separate tab
import seaborn as sb
#this library provide more concise and easier codes than matplotlib.pyplot
df = pd.read_csv('StudentsPerformance.csv')
# now we will use pandas to show the csv file that we will work on
df

df.nunique()
#it turns the columns into rows and shows us the number of distinct elements

df.head(10)
#if we didn't write anything inside the parenthesis it will show us the first 5 rows frim every column

df.tail()
#if we didn't write anything inside the parenthesis it will show us the last 5 rows frim every column

df.shape
#it shows the number of rows(left) and columns(right)

df.size
#it shows the number of elements (the number of rows pultiplied by the nuber of columns)

df.shape[0]
#now it will show us the number of rows , if we write 1 insted of 0 it will show the number of columns

len(df)
#this is also a different way to show the number of rows

len(df.columns)
#this is also a different way to show the number of columns

df.dtypes
# this will show us the different types of different elements inside every column

df.gender
#we use this code to show a specified column

df['gender']
#this is a different way to show columns

df['gender'].head(3)
#we use this if we want to show only the first few elements of a specified column

df.loc[:2, 'gender']
#this is a differnet way to show only the first few elements of a specified column using slicing

df.iloc[:3, 0]
#this is also a differnet way to show only the first few elements of a specified column using slicing

df[['gender', 'lunch', 'math score']]
#we use this if we want to show only the first few elements of many specified columns

df.loc[10:15, ['gender', 'lunch', 'math score']]
#this is a differnet way to show a range pf specified elements of amany specified columns using slicing

df.iloc[10:16, [0, 5, 7]]
#this is also differnet way to show a range pf specified elements of amany specified columns using slicing

df['gender'].value_counts()
#this code shows the number of repeated elemnts inside a specified column

df['gender'].value_counts() / len(df)
#we use this vode to get the probability from the dataset

df[df['gender'] == 'female']

df[df['gender'] == 'female']['math score'].value_counts()
#we use this code to show how many females get a certain score in the specified subject

df[df['gender'] == 'female']['math score'].value_counts() / len(df[df['gender'] == 'female'])
# we use this to get the probability

df[df['gender'] == 'male']['math score'].value_counts()
#we use this code to show how many males get a certain score in the specified subject

df[df['gender'] == 'male']['math score'].value_counts() / len(df[df['gender'] == 'male'])
# we use this to get the probability

df['test'] = df['test preparation course'].map(lambda x: 1 if x == 'completed' else 0)
# we use this code to add a new column and to add new elements that is created based on other elements that do already exist but not
# in a simplified form . and this is why we make a new column that includes the simplified form
df

pd.crosstab(df.gender , df.lunch)
#we use this to make a small table that shows the common elements of two columns

pd.crosstab(df.gender, df.lunch, margins = True)
#we use this to make a small table that shows the common elements of two columns and the total number of these common elements

pd.crosstab(df.gender, df.lunch).plot(kind = 'bar');
#this is called "visualization" and it provides an easier way to see the data for the viewer of the reader

df.rename(columns = {'race/ethnicity':'race'}, inplace = True)
#we use the function rename to change the name of a specified column , we can write a more brief name using this way
df

df_2 = df.transpose()
#we use this to change the rows to elements and vice versa
df_2

df1 = df[['race', 'math score']][:3]
df2 = df[['race', 'math score']][3:]
#we made these two variables ao we can add them later

df1

df2

df_append = pd.concat([df1, df2])
df_append
# this is how we add two variables

df['race'].unique()
# we use this function to know the distinct elemnets in a specified column

for i, v in enumerate(df.columns):
    print(i, v)
    #this is a way to see the columns separate from rows and the rest of the elements

df_miss = df.loc[:,'gender':'test']
df_miss.to_csv('missing_data.csv', index=False)
#we created this new file to use the function info to check for any misssing data
df_miss.info()
#this is to check if there is any missing data through checking the number besides non_null and compare it to 1000
#we realize after comparison that there is difference between the provided data and the total number of data
#meaning there is no mising data

df.duplicated().sum()
#we use this code to know the sum of the duplicated elemnets.
#since the sum is 0 then we can conclude that there is no duplicated elements
#the data does not need to be cleaned

# Return the Series having unique values
x = df['race'].value_counts().index

# Return the Series having frequency count of each unique value
y = df['race'].value_counts()

plt.bar(x, y)

# Labeling the axes
plt.xlabel('Race')
plt.ylabel('Count')

# Dsiplay the plot
plt.show()
#this is how we create a vertical bar chart using matplotlib

sb.countplot(data=df, x='race');
#using ; is important while using functions from this library
#we notice that _unlike the chart that we did by batplotlib_ it is not in descending order

# The `color_palette()` returns the the current / default palette as a list of RGB tuples.
# Each tuple consists of three digits specifying the red, green, and blue channel values to specify a color.
# Choose the first tuple of RGB colors
base_color = sb.color_palette()[0]
# Dynamic-ordering the bars
# The order of the display of the bars can be computed with the following logic.
# Count the frequency of each unique value in the 'race' column, and sort it in descending order
# Returns a Series
freq = df['race'].value_counts()
# Get the indexes of the Series
gen_order = freq.index
# Plot the bar chart in the decreasing order of the frequency of the `race`
sb.countplot(data=df, x='race', color=base_color, order=gen_order);
# Static-ordering the bars
#this is how we achieve the descending order

sb.countplot(data=df, x='race', color=base_color);
plt.xticks(rotation = 45);
#this is how we rotate the words on the x-axis with an angle of 45

type_order = df['race'].value_counts().index
sb.countplot(data=df, y='race', color=base_color, order=type_order)
#this is how we make the chart rotate clockwise instead of the more common form

sorted_counts = df['race'].value_counts()
gen_percentage = sorted_counts/sorted_counts.sum()
plt.pie(gen_percentage, labels = sorted_counts.index, startangle = 180, counterclock = True);
#this is how we do pie chart

plt.hist(data = df, x = 'race', bins = 5);
#this is how we do histogram

df['race'].describe()

sb.histplot(df['race']);
#this is how we separate between the columns with lines

plt.scatter(data = df2, x = 'race', y = 'math score');
plt.xlabel('race');
plt.ylabel('math score)');
#this is how we do scatter plot

base_color = sb.color_palette()[0]
sb.boxplot(data=df2, x='race', y='math score', color=base_color)
plt.xticks(rotation=45);
#this is how we do a box blot

#there is two kinds of supervised learning : regression and classification
#in this case we are going to classify the students to either (successful) or (failure) which means we are going to use
#classification
df = df.drop(['race', 'gender', 'lunch', 'test preparation course', 'parental level of education'], axis=1)
df

#now what we are going to do is making functions that check if the student either pass of fail math , reading and writing
# pass means 1 and fail means 0
df['math_check'] = df['math score'].map(lambda x: 1 if x >= 50 else 0)
df['reading_check'] = df['reading score'].map(lambda x: 1 if x >= 50 else 0)
df['writing_check'] = df['writing score'].map(lambda x: 1 if x >= 50 else 0)

# Now calculate the number of subjects passed for each student
df['passed_count'] = (df[['math_check', 'reading_check', 'writing_check']] == 1).sum(axis=1)

df

#now we are going to ckeck if the student is "succesful" or a "failure".
#we are going to make a function that checks if a student passed 2 subjects or more ,
#if the student did then he is "succesful" if not them he is "failure"
df['outcome'] = df['passed_count'].map(lambda x: 'succesful' if x >= 2 else 'failure')
df

#we don't need to Convert categorical variables to dummy variables
#nor we need to use dropna() since we have established that ther ther is no missing data
#we will split the data to traning and test data
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(df.drop('outcome', axis=1), df['outcome'], test_size=0.2, random_state=0)

# Fit a logistic regression model
from sklearn.linear_model import LogisticRegression
log_reg = LogisticRegression()
log_reg.fit(X_train, y_train)

# Make predictions on the testing set
y_pred = log_reg.predict(X_test)

# Evaluate the accuracy of the model
from sklearn.metrics import accuracy_score
accuracy = accuracy_score(y_test, y_pred)
print('Accuracy:', accuracy)

#sometimes, it can be hard to have high accuracy like the case above. in such cases we use Support Vector Machine (SVM)
X = df.iloc[:, 1:6].values
y = df.iloc[:, 6].values

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

from sklearn.svm import SVC
svm = SVC()
svm.fit(X_train, y_train)

y_pred = svm.predict(X_test)

from sklearn.metrics import accuracy_score
accuracy = accuracy_score(y_test, y_pred)
print('Accuracy:', accuracy)